---
title: "React基礎"
emoji: "🤣"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["React", "フロントエンド"]
published: false
---

typescriptと関数コンポーネントをベースにReactの基本に触れていきます。
これからReactに入門する方に対して、実務でReactを使う上での**下地**をつくることが本記事の目的です。

したがって、細かい部分には触れず、概要を掴むことに重きを置きます。

※また、html・css・js(node.js)・typescriptを一定レベル理解している前提で説明いたします。その点ご了承ください。

## Reactとは
Reactとは、UI構築のためのJSライブラリです。
大きく2点の特徴があります。

- 宣言的なview
- コンポーネントベース

宣言的なビューとは、状態に応じた処理やUIの表示内容を宣言できるということです。
従来、宣言的の反対である命令的という概念でUIが実装されていました。
命令的だと1回1回処理をステップごとに細かく記述する必要があり、直感的ではなく不便でした。
そこであらかじめ**1回1回命令**していた処理を**まとめて宣言**することで、直感的なUIの構築が可能になります。

宣言的なviewについて、以下の記事が参考になるかと思います。
https://zenn.dev/arei/articles/f59e263aa3edf2


コンポーネントベースとは、コンポーネントという単位を組み合わせてUIを開発することです。
コンポーネントは値を「状態（state）」として保持することもできます。（stateの扱い方については後述）
UIの機能や役割などに応じてDOMを分割することで、複雑なUIを構築しやすく安全な実装をすることができます。

コンポーネントベースについては、下記の記事が参考になるかと思います。
https://qiita.com/thim/items/c46bb888c864c0360e22

コンポーネントに関してですが、クラスコンポーネントと関数コンポーネントの2種類があります。
現状では関数コンポーネントの方が主流なので、書き方を合わせましょう。

## コンポーネントの書き方
基本的なコンポーネントの書き方を紹介致します。

コンポーネントは以下のような書き方で書けます。

```tsx
const Child = () => {
  return (
    <div>
      <p>こんにちは</p>
    </div>
  );
}
```

呼び出す際もシンプルです。
Parentという親のコンポーネントから子のコンポーネントとしてChild呼び出します。

```tsx
const Parent = () => {
  return <Child />
}
```


データを親から子に渡したい時があるかと思います。
その際は属性の値として、バケツリレーで値を送ることができます。

```tsx
// React.VC→Reactの関数コンポーネントの型
const Parent: React.VC = () => {
  const greeting = "こんにちは";
  return <Child greeting={greeting} />
}

type Props = {
  // optionalにすると親から値が渡らないことを許容できる
  greeting: string;
};

const Child: React.VC<Props> = ({ greeting }) => {
  return (
    <div>
      <p>{ greeting }</p>
    </div>
  );
}
```

さらにコンポーネントの中にコンポーネントを組み込みたいといった、Wrapperとしてのコンポーネントも実装することができます。

```tsx
// React.VC→Reactの関数コンポーネントの型
const Parent: React.VC = () => {
  return (
    <Child>
      <p>こんにちは</p>
    </Child>
  );
}


const Child: React.VC = ({ children }) => {
  // 呼び出された際に挟んだコンポーネント、DOMが入ってくる
  return (
    <div>
      {children}
    </div>
  );
}
```

## 基本のhooks
今まで触れてきたコンポーネントの書き方をベースにReact固有の関数であるhooksについて触れていきます。

### useState
先ほどコンポーネントは値を状態として保持することができると言及しました。
useStateは状態であるstateの値を設定することができるhooksです。

`isLoading`はstateの値で、`setIsLoading`でstateの値を変更することができる関数です。

```tsx
const [isLoading, setIsLoading] = useState<boolean>(false);
```

stateの値を使うことで、複雑なUIを実装することが可能です。

どういうことか。

そのためには、Reactのコンポーネントが再レンダリングするタイミングを知る必要があります。再レンダリングするタイミングは以下です。

- stateが更新されたとき
- コンポーネントにわたってきたpropsの値が変更されたとき
- 親のコンポーネントがレンダリングしたとき


つまり、stateが変更されたら、該当のstateを保持しているコンポーネントでは再レンダリングが発生します。

以下のサンプルコードでは、必要なデータを取得できたかに応じてisLoadingの値とUIを変更しています。

```tsx
const Component: React.FC = () => {
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [data, setData] = useState<Data>(initialvalue);

  // useEffectについては後で触れます。
  // とりあえず、データを取得してstateにセットして、loadingのstateを変更していることを想定してください。
  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true);
      const fetchedData = await fetchData();
      setData(fetchedData);
      setIsLoading(false);
    };
    fetchData();
  }, []);


  return (
    <>
      { // 三項演算子で表現する
        isLoading ? (
        // スピナーを表示
        <Spinner />
      ) : (
        // 通常のコンテンツを表示
        <Contents data={data} />
      )}
    </>
  );
};
```

このようにstateを管理することで、それに応じた動的なUIを比較的に直感的に構築できます。

### useEffect
useEffectは関数の実行をレンダリングの後にまで遅らせることができます。

先ほどの例では非同期でデータを取得するために使っていました。他にもstateや変数に応じたDOMの変更などに使うことができます。

第一引数では実行する関数、第二引数では関数の実行に依存する値を配列の形でセットします。
空配列の場合、コンポーネントの初回レンダリングのみ関数を実行します。

```tsx
useEffect(() => {}, []);
```

詳しくはuseEffectに関する記事をご覧ください。
https://qiita.com/seira/items/e62890f11e91f6b9653f

### useContext
reactコンポーネントでは、親からpropsで子に値を送ることができますが、多くの場合コンポーネントは何重もの入れ子になるでしょう。
複雑に入れ子になるとバケツリレーが何回も行われるので、値を追う労力が増えます。
useContextを使うと、親からpropsで受け取らなくても値を受け取ることができます。

例として、`GrandParent -> Parent -> Child`といった入れ子のコンポーネントで、トップから最下層にデータを送りたい場合を想定します。

```tsx
type Props = {
  username: string;
}

const GrandParent: React.FC = () => {
  const username = "hoge";
  return <Parent username={username} />;
};

// ただ中継しているだけ
const Parent: React.FC<Props> = ({ username }) => {
  return <Child username={username} />;
};

const Child: React.FC<Props> = ({ username }) => {
  return <p>{username}</p>;
};
```

useContextを使うとこうなります。（別ファイルに分割したい時は脳内で置き換えて考えてください）

```tsx

export const UsernameContext = createContext<string>("");

const GrandParent: React.FC = () => {
  const username = "hoge";
  return (
    // トップコンポーネントでcreateContextで作成したプロバイダーでラップする
    <UsernameContext.Provider value={username}>
      <Parent />
    </UsernameContext.Provider>
  );
};

const Parent: React.FC = () => {
  return <Child />;
};

const Child: React.FC = () => {
  // プロバイダーでラップした時に設定した値を、useContextで取得する
  const username = useContext(UsernameContext);
  return <p>{username}</p>;
};
```

このようにuseContextを正しく使うことで、下層コンポーネントで値を呼び出すことが容易になります。

### useReducer
useReducerは状態管理のためのhooksでuseStateと似ています。

`const [state, dispatch] = useReducer(reducer,initialState)`という構文で、stateとそれを更新するdispatchで構成されています。

```tsx

type Action = {
  type: "UPDATE_NAME";
  payload: string;
};

const Component: React.FC = () => {
  const user = {
    name: "",
    age: 0,
  };

  const reducer = (userdata: { name: string; age: number }, action: Action) => {
    switch (action.type) {
      case "UPDATE_NAME":
        return {
          ...userdata,
          name: action.payload,
        };
      default:
        return userdata;
    }
  };

  const [userState, dispatch] = useReducer(reducer, user);
  return (
    <input
      onChange={(e) =>
        dispatch({
          type: "UPDATE_NAME",
          payload: e.currentTarget.value,
        })
      }
    />
  );
};
export default Component;
```

## パフォーマンスを良くするには

### React.memo
### useCallback
### useMemo


## 次に勉強するべきこと


## まとめ


## 参考文献


